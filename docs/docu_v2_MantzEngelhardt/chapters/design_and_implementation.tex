\chapter{Design and Implementation}\label{ch:design_and_implementation}

This chapter covers the design and implementation of the new features. It also addresses structural changes, that were necessary for these features to be implemented, as well as optimizations and bugfixes in the original codebase.


\section{Memory Optimizations\label{sec:cleanup.mem}}

\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{gfx/queue_arch}
	\caption{Signal processing architecture with blocking queues}
	\label{fig:queue_architecture}
\end{figure}

The original RF Analyzer application's architecture is based on
blocking queues that synchronize the various signal processing threads
and efficiently manage memory buffers. Unfortunately, this
architecture was partly dropped by the developers of \ac{AnSiAn} when
changing to a new architecture that is based on the EventBus library. As a result, memory
allocation management does not work as efficiently with the original version
of \ac{AnSiAn}.

Instead of using cycling buffers for inter-thread-communication, \ac{AnSiAn} uses
EventBus to deliver data. Buffers are always allocated freshly
and discarded after use. This results in a high activity of the
\ac{GC} and therefore in a bad overall performance of the app.

\autoref{lst:before_mem_optimization} shows a logcat output of the
app before any optimizations were applied. The \ac{GC} runs approximately 8 times per second
and the slow performance results in stuttering audio demodulation on
older hardware.

\begin{lstlisting}[label=lst:before_mem_optimization, caption=Logcat output
before memory optimizations, language=none]
05-12 17:55:04.060 D/dalvikvm: GC_FOR_ALLOC freed 4347K, 14% free 54695K/62984K, paused 28ms, total 28ms
05-12 17:55:04.180 D/dalvikvm: GC_FOR_ALLOC freed 4321K, 14% free 54737K/62984K, paused 26ms, total 26ms
05-12 17:55:04.300 D/dalvikvm: GC_FOR_ALLOC freed 4507K, 14% free 54705K/62984K, paused 32ms, total 32ms
05-12 17:55:04.420 D/dalvikvm: GC_FOR_ALLOC freed 4454K, 14% free 54759K/62984K, paused 30ms, total 30ms
\end{lstlisting}

In order to fix this performance issue, the architecture was reverted
to using blocking queues and cycling buffers in places where large memory buffers are passed
between threads. EventBus is still used to deliver information
which is not tied to large buffers. A schema of the new architecture
is depicted in \autoref{fig:queue_architecture}.

In this architecture, the buffers cycle between the threads. The re-usage
of buffers helps to reduce the memory allocation and garbage collection
overhead to a minimum. \autoref{lst:after_mem_optimization} shows the
logcat output after the architectural changes have been applied. The \ac{GC}
only needs to run every 10 to 20 seconds.


\begin{lstlisting}[label=lst:after_mem_optimization, caption=Logcat output
after memory optimizations, language=none]
05-12 17:27:29.230 D/dalvikvm: GC_FOR_ALLOC freed 3233K, 15% free 19706K/23000K, paused 32ms, total 33ms
05-12 17:27:40.780 D/dalvikvm: GC_FOR_ALLOC freed 3528K, 16% free 20235K/23824K, paused 30ms, total 31ms
05-12 17:28:00.110 D/dalvikvm: GC_FOR_ALLOC freed 4130K, 18% free 20338K/24528K, paused 36ms, total 37ms
05-12 17:28:24.520 D/dalvikvm: GC_FOR_ALLOC freed 4263K, 18% free 20341K/24664K, paused 49ms, total 49ms
\end{lstlisting}

Another significant performance improvement can be achieved by synchronizing
the calculation of the \ac{FFT} to the refresh cycle of the application
\ac{GUI}. This simple change reduces the number of times the \ac{FFT} algorithm
has to be executed and releases processing resources for other calculations
(e.g. the demodulation path). 

Unfortunately, it turned out that the Morse demodulation
algorithm of \ac{AnSiAn} was working in the frequency
domain and relied on continuous \ac{FFT} samples without gaps.
As result, this performance improvement comes at the cost of re-implementing
the Morse demodulation algorithm in order to work on time domain samples
instead.


\section{Demodulation}

This section describes the design and implementation process of the developed demodulation features. \autoref{sec:demod_design} covers where and how the new demodulators and the logging functionality were integrated into the existing architecture and which changes were necessary. Due to performance issues with the old frequency-domain-based Morse demodulator, it had to be re-written. This process is described in \label{sec:morse_demod}. The implementation of the new \ac{RDS} and \ac{PSK31} demodulators is covered in Sections \ref{sec:rds} and \ref{sec:psk31} respectively. \autoref{sec:logging} addresses the implemented logging functionality for demodulator output.


\subsection{Design and Structural Changes\label{sec:demod_design}}

The existing architecture of \ac{AnSiAn} features individual threads for scheduling, 
downsampling, demodulation and audio output. The \texttt{De\-mo\-du\-la\-tor} thread demodulates 
quadrature samples by calling the \texttt{demodulate()} method on an instance of
\texttt{Demodulation}. \texttt{Demodulation} is an abstract class that is implemented by concrete 
demodulation methods such as \texttt{AM}, \texttt{FM} and \texttt{Morse}. 

\ac{AnSiAn} utilizes the EventBus library in order to pass demodulated Morse text
to the \ac{GUI}. Demodulated audio data is passed to the
\texttt{AudioSink} thread by enqueuing it into its input queue.
This mechanism was explained in more detail in \autoref{sec:cleanup.mem}.


In order to extend \ac{AnSiAn} with demodulation functionality for \ac{PSK31} and \ac{RDS}, 
the existing architecture needs to be extended by two new subclasses. The extended architecture is
depicted in \autoref{fig:demod_text_eventbus} and explained in the following.

\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{gfx/demod_text_eventbus.png}
	\caption{Architecture of the extended demodulation logic and communication with the GUI}
	\label{fig:demod_text_eventbus}
\end{figure}

Two new classes \texttt{PSK31} and \texttt{RDS} are created and instantiated as attributes by the existing demodulation classes for \ac{USB} and \ac{FM}. \ac{PSK31} demodulation
works on the envelope of the received \ac{USB} signal. \ac{RDS} transmits
metadata for \ac{FM} radio channels, which is why the \ac{RDS} demodulation
needs to work on an intermediate result of the wide-band \ac{FM} demodulation
class. Through a new option in the app settings, it is possible to enable
or disable the demodulation of the embedded digital modes when the
corresponding analog mode is selected.

Like the existing architecture, the new architecture uses the EventBus
library to pass the demodulated text to the \ac{GUI}. The existing View
\texttt{MorseReceiveView} is refactored into a universal
\texttt{De\-mo\-du\-la\-tion\-In\-fo\-View} that displays the text output of any selected 
demodulator. Demodulators pass
\texttt{DemodInfoEvent}s via the EventBus to the \texttt{De\-mo\-du\-la\-tion\-In\-fo\-View}, 
which contain demodulated text and further information (e.g. baud rates or raw 
dits and dahs) and are displayed in separate lines.

The new class \texttt{Logger} will also listen for \texttt{DemodInfoEvent}s and, if logfiles for demodulator output are enabled by the user, persist the demodulated data to these logfiles.

\subsection{Re-Implementation of Morse Demodulator\label{sec:morse_demod}}

As explained in \autoref{sec:cleanup.mem}, the original version of \ac{AnSiAn} calculated \acp{FFT} excessively often and thus offered bad performance. \ac{AnSiAn}'s original Morse demodulator, which operated in the frequency domain, relied on frequent \ac{FFT} calculations and did not work after the optimizations described in \autoref{sec:cleanup.mem}. In order to still demodulate Morse with the new efficient architecture, the Morse demodulator needed to be re-written to work in the time domain rather than the computationally expensive frequency domain.

\subsubsection{Requirements}

Aside from demodulating and decoding Morse transmissions, the old demodulator offered support for the following features, which the new demodulator should implement as well.

\begin{itemize}
  \item ``Manual'', ``semi-automatic'' or ``automatic'' detection of dit duration and threshold
  \item Optional automatic re-initialization of detected dit duration and threshold in case of high error rate
  \item Optional \ac{AM} audio demodulation along with Morse demodulation
\end{itemize}

In automatic mode, the demodulator automatically estimates the high/low threshold and the duration of a dit based on a set of samples, that needs to be collected before the actual demodulation can start. Manual mode requires the user to explicitly specify the dit duration and uses the current squelch as threshold. In semi-automatic mode, the user specifies the dit duration while the threshold is determined automatically.

With the new demodulator getting its samples from the \texttt{Decimator} rather than the \texttt{FFTCalcThread}, the practice of using the squelch as threshold is no longer applicable, as samples below the squelch level do not get passed to the \texttt{Demodulator}. The new implementation of the Morse demodulator thus only supports ``automatic'' and ``manual'' mode with respect to dit duration; the threshold is always determined automatically.


\subsubsection{Implementation}

\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{gfx/morse_states.png}
	\caption{States and state transitions of the re-written Morse demodulator}
	\label{fig:morse_states}
\end{figure}

The re-written Morse demodulator has five states that are displayed in \autoref{fig:morse_states} and explained in the following.

\paragraph{INIT} In this state, the demodulator initializes its internal state. Samples received while in this state are discarded and not demodulated. In case \ac{AM} demodulation is activated, audio still is demodulated.
\paragraph{COLLECT\_{}SAMPLES} The demodulator calculates and stores the envelope of all received samples in a buffer. In case \ac{AM} demodulation is activated, audio is demodulated.
\paragraph{INIT\_{}STATS} The collected samples from the previous state are used to initialize the threshold and, optionally, the dit duration. Samples received while in this state are discarded and not demodulated. In case \ac{AM} demodulation is activated, audio still is demodulated.
\paragraph{DEMOD} Received samples are demodulated on-the-fly. If demodulation or decoding error rates are beyond a threshold, the demodulator re-initializes.
\paragraph{STOPPED} The demodulator should not be running; all samples are discarded.
\paragraph{}

For envelope detection, $\sqrt{I^{2}+Q^{2}}$ is used, with $I$ and $Q$ being the inphase and quadrature components of the sample, respectively. This is computationally more expensive than using the existing \ac{AM} demodulator to detect the envelope, but produces more exact results and comes without the unwanted automatic gain control of the \ac{AM} demodulator. For efficient memory management, the envelope of the currently processed sample packet is not always stored in a new array. Instead, a buffer is allocated once and overwritten with the current envelope each time a new sample packet is processed. If \ac{AM} demodulation is enabled, the envelope is copied from the buffer to the demodulator output, which is passed to the \texttt{AudioSink}.

The threshold, that determines whether a given sample is a ``low'' or a ``high'' sample (i.e. if it is part of a dit/dah or a pause), is initialized based on the initialization data collected during the COLLECT\_{}SAMPLES step and continuously updated for every processed sample. It is calculated as $bottom + \frac{peak - bottom}{2}$, with $bottom$ being the lowest and $peak$ being the highest amplitude seen since the demodulator's initialization.

If automatic mode is enabled, the dit duration is determined by counting streaks of consecutive ``high'' (i.e. bigger than the threshold) samples in the initialization data. The observed streak lengths are then adjusted by adding the number of observed streaks with one sample more or less (i.e. $o_{new}(x) = o(x-1) + o(x)+ o(x+1)$ with $o(x)$ being the number of occurrences of a continuous high-streak of $x$ samples). This is done to cope with outliers. The most frequently observed streak length is assumed to be the number of samples per dit. If this number of samples corresponds to less than \SI{7}{\milli\second} of samples, it is assumed that the initialization data was of poor quality and the demodulator reinitializes itself.

In DEMOD state, streaks of continuous high and low values in the currently processed samples packet are counted. The length of a streak and its value (i.e. high or low) are then decoded to find out whether it encodes a dit, dah or a short, medium or long pause. If a medium pause (encodes the end of character symbol) is detected, the previous dits and dahs are passed to the \texttt{Decoder} class, which translates them into a character. The \texttt{Decoder} class was already used by the old demodulator. It was originally taken from the open-source project Morsecoder and recycled for the new Morse demodulator.

To implement automatic re-initialization, the demodulator uses \texttt{Er\-ror\-Bit\-Set}s, which are essentially ring buffers for boolean values. Two \texttt{Er\-ror\-Bit\-Set}s are used; one for demodulation (i.e. translating streak lengths into dits, dahs and pauses) and one for decoding (i.e. translating dits and dahs into characters). Every entry represents a successful or unsuccessful decoding/demodulation attempt. The size of the \texttt{Er\-ror\-Bit\-Set} that tracks demodulation success is 100, the size for the decoding success \texttt{Er\-ror\-Bit\-Set} is 30. If the success rate drops below 50\%, the demodulator re-initializes itself and thus re-determines the threshold and, if automatic mode is enabled, dit duration.


\autoref{lst:morse_demod_method} shows an excerpt of the demodulator's core method \texttt{de\-mo\-du\-late()}. The operation of the demodulator, as described in this section, can be recognized in it.

\begin{lstlisting}[label=lst:morse_demod_method, caption=The demodulate method of the new Morse demodulator (excerpt), language=java]
switch (this.state) {
    case INIT:
        if (amDemod) {
            // do nothing except AM Demodulation; Demodulator might be in inconsistent state
            envelopeToBuffer(input);
            amDemodFromBuffer(output);
        }
        break;
    case COLLECT_SAMPLES:
        // collect samples and write them to initSamples until we have enough
        envelopeToBuffer(input);
        if (amDemod)
            amDemodFromBuffer(output);
        collectSamplesFromBuffer();
        if (!(initSamplesCollected < initSamplesRequiredForInit))
            initializeStats();
        break;
    case INIT_STATS:
        if (amDemod) {
            // do nothing except AM Demodulation; Demodulator might be in inconsistent state
            envelopeToBuffer(input);
            amDemodFromBuffer(output);
        }
        break;
    case DEMOD:
        // demodulate samples
        envelopeToBuffer(input);
        if (amDemod)
            amDemodFromBuffer(output);
        updateThresholdFromBuffer();
        binarizeBuffer();
        demodulateBuffer();
        if (automaticReinit && needsReinit())
            init();
        break;
    case STOPPED:
        // discard samples; Demodulator should not be running
}
\end{lstlisting}

A screenshot of the running Morse demodulator can be seen in \autoref{fig:morse_screenshot_new}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\linewidth]{gfx/screenshots/morse_screenshot_new.png}
	\caption{Screenshot of the Morse demodulator on a Nexus 5X}
	\label{fig:morse_screenshot_new}
\end{figure}



\subsection{Radio Data System \label{sec:rds}}

The \ac{RDS} signal is transmitted along with wide band \ac{FM}
radio signals to provide additional information about the
radio station and program.

Demodulation of the \ac{RDS} signal is first done in Octave in order to
evaluate the demodulation algorithm. The octave implementation
also helps by providing reference data of the different stages
of demodulation. 

\subsubsection{RDS modulation scheme}
\label{sec:rds_modulation_scheme}

\ac{RDS} uses \ac{BPSK} with Manchester encoding. The signal is
transmitted with an offset of 57 kHz relative to the center frequency
of the mono audio signal (baseband). The 19 kHz pilot tone of wideband \ac{FM}
can therefore be used to retrieve the \ac{RDS} carrier by multiplying
it with itself 3 times. The complete FM spectrum can be seen in
\autoref{fig:quad_demod_spectrum}.

After the \ac{RDS} baseband signal has been retrieved from the \ac{FM} signal
there are multiple ways of demodulating the \ac{BPSK} modulation. A sophisticated
approach tries to recover the phase synchronized \ac{RDS} carrier from the
signal by using e.g. a form of \ac{PLL} or Costas Loop. The symbols can then
be extracted by multiplying the carrier with the modulated signal and apply
a threshold operation to get bits.

A much simpler approach is to analyze the envelope of the signal and detect
bits based on known shapes of ones and zeros in the waveform.
\autoref{fig:rds_envelope} shows the envelope and the pattern of symbols
which can be detected.

\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{gfx/rds/rds_waveform.png}
	\caption[RDS envelope waveform after Frequency demodulation]{RDS envelope waveform after Frequency demodulation \cite{1999:iec62106}}
	\label{fig:rds_envelope}
\end{figure}



\subsubsection{RDS coding scheme}

RDS frames are called groups and each group consists of 4 blocks called
A, B, C and D. One block has a length of 16 bit plus a 10 bit checkword.
Block A always contains the \ac{PI} which identifies the radio station.
The content of the other blocks depends on the group type which is located
in block B (see \autoref{fig:rds_group0A}).

\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{gfx/rds/group0A.png}
	\caption[Coding scheme of RDS: group 0A]{Coding scheme of RDS: group 0A \cite{1999:iec62106}}
	\label{fig:rds_group0A}
\end{figure}

\autoref{tab:rds_groups} (see appendix) lists all group types and their descriptions.
The \ac{RDS} demodulation in AnSiAn only decodes types 0 and 2 because they contain
the basic information which is also often displayed on the radio
receiver.


\subsubsection{Evaluation in Octave}

Developing a signal processing application on Android has many drawbacks. One
issue is that it is very hard to debug the actual signal processing components
because of the lack of proper tools to visualize and analyze the data that is
being processed. It is also not possible to do rapid prototyping without
sufficient signal processing libraries available. Therefore, the \ac{RDS}
demodulator was first developed in Octave and afterwards ported to Android.

For development and testing it is better to work on recorded samples instead
of live captures. This makes tests reproducible and simplifies the development
environment. The file was recorded using the record feature of RF Analyzer. It
can be imported in Octave by using the \texttt{read\_cuchar\_binary()} script
provided by the GNU Radio project. After each step the produced output data
can be written back to an \emph{IQ} file in order to use it in the Android application.
This way it is possible to develop each component of the demodulation process
separately and the output can be visualized on the developing machine.

The demodulation is done in the following steps:
\begin{enumerate}
	\item Downmixing the radio signal to baseband and filter it (see 
		\autoref{fig:rds_downmixing}).
	\item \ac{FM} demodulation (see \autoref{fig:quad_demod_spectrum}).
	\item Downmixing the \ac{RDS} signal to baseband and filter it
		(see \autoref{fig:rds_extraction} b and c).
	\item Take the absolute value of the signal to get the envelope
		that was shown above (see \autoref{fig:rds_waveform}).
	\item Find the beginning of a symbol by searching for a minimum in
		the waveform. From there find the end of the symbol with the
		same strategy. Now determine whether the symbol is a one or a
		zero according to the value of the minimum found in the middle
		of the sample compared to its peaks.
\end{enumerate}

\begin{figure}
\subfloat[Spectrum of the captured signal]{%
  \includegraphics[clip,width=1\linewidth]{gfx/rds/raw_signal_spectrum.png}%
}

\subfloat[Spectrum after downmixing and filtering]{%
  \includegraphics[clip,width=1\linewidth]{gfx/rds/fm_baseband_filtered_spectrum.png}%
}
\caption{FM Modulated Signal}
\label{fig:rds_downmixing}
\end{figure}


\begin{figure}
\subfloat[Signal spectrum after FM demodulation]{%
  \includegraphics[clip,width=1\linewidth]{gfx/rds/quad_demod_spectrum.png}%
  \label{fig:quad_demod_spectrum}
}

\subfloat[RDS baseband spectrum after downmixing]{%
  \includegraphics[clip,width=1\linewidth]{gfx/rds/rds_baseband_unfiltered_spectrum.png}%
}

\subfloat[RDS baseband spectrum after filtering]{%
  \includegraphics[clip,width=1\linewidth]{gfx/rds/rds_baseband_spectrum.png}%
}
\caption{Extracting the RDS signal from the FM signal}
\label{fig:rds_extraction}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=1.1\linewidth]{gfx/rds/rds_magnitude_waveform.png}
	\caption{RDS waveform after take the absolute values}
	\label{fig:rds_waveform}
\end{figure}

The octave code used to execute the steps mentioned above is shown in the
listing below:

\begin{lstlisting}[label=lst:octave_rds, caption=Octave implementation of the RDS demodulator, language=octave]
signal = read_cuchar_binary ("rtlsdr_100550000Hz_1000000Sps.iq");
t = linspace(0, length(signal)/1000000, length(signal))';
carrier = e.^(2*pi*-245000*t*i);
down = carrier .* signal;
fl = fir1(300, 100000/1000000*2);
filtered = filter(fl, 1, down);
demod = quad_demod(filtered, 1);
t2 = linspace(0, length(demod)/1000000, length(demod));
rdscarrier = cos(2*pi*-57000*t2)';
rdsbase = demod(1:length(rdscarrier)) .* rdscarrier ;
frds = fir1(300, 2400/1000000*2);
rdsbase_filtered = filter(frds,1,rdsbase);
downsampled = decimate(rdsbase_filtered, 16).*80;
write_cuchar_binary (downsampled, "rds_baseband_62500sps.iq");
bits = rds_bpsk_demodulate(downsampled, 62500);
rds_decode(bits)
\end{lstlisting}

The \texttt{quad\_demod()} function does the quadrature demodulation
(FM demodulation). The \texttt{rds\_bpsk\_demodulate()} function is shown
in the following listing:

\begin{lstlisting}[label=lst:octave_rds_bpsk, caption=Octave implementation of the BPSK demodulation, language=octave]
function demod = rds_bpsk_demodulate(signal, fs)
  samples_per_symbol = fs/1187.5
  samples_per_symbol = ceil(samples_per_symbol)
  envelope = abs(signal);
  
  % Find the first minimum
  [minimum, idx1] = min(envelope(1:samples_per_symbol))
  
  bits = [];
  while (idx1 + samples_per_symbol*2 < length(envelope))
    % find end of symbol idx2 (minimum near idx1 + samples_per_symbol)
    from = round(idx1+samples_per_symbol*0.75);
    to   = round(idx1+samples_per_symbol*1.25);
    [minimum, idx2] = min(envelope(from:to));
    idx2 = idx2 + from;
    
    % calc mean of all samples between idx1 and idx2 and calc threshold = mean/2
    m = mean(envelope(idx1:idx2));
    threshold = m/2;
    
    % get minimum sample in the middle between idx1 and idx2 ...
    span = idx2 - idx1;
    from = round((idx1+idx2)*0.5 - 0.25*span);
    to   = round((idx1+idx2)*0.5 + 0.25*span);
    [minimum, idxmiddle] = min(envelope(from:to));
    idxmiddle = idxmiddle + from;
    
    % Check whether we have the correct timing. It might be, that idx2 is
    % actually in the middle of a symbol than at its end.
    if (envelope(idx2) > threshold)
      % In this case we find the minimum between idx1 and idx2 and set it
      % as idx1 for the next round:
      %printf("WARNING: Wrong timing. thres=%f < envelope(idx2=%d)=%f\n",threshold,idx2,envelope(idx2));
      idx1 = idxmiddle;
      continue;
    endif
    
    % ... and check it against the threshold
    s = envelope(idxmiddle);
    if (s > threshold)
      bits = [bits 1];
    else
      bits = [bits 0];
    endif
    
    % idx1 = idx2 and continue with the next symbol..
    idx1 = idx2;
    
  endwhile
  demod = bits;
\end{lstlisting}


\subsubsection{Android Implementation}

For the Android implementation two classes are added to the AnSiAn codebase:
\begin{itemize}
	\item \texttt{BPSK}: This class handles the \ac{BPSK} demodulation and can be
		reused by other demodulators using the \ac{BPSK} modulation scheme
		(e.g. PSK31).
	\item \texttt{RDS}: This class integrates in the existing FM class for frequency
		demodulation. It handles the decoding and processing of \ac{RDS}
		groups. 
\end{itemize}

A screenshot of the application demodulating the \ac{RDS} signal of the
\emph{Antenne Frankfurt} station is shown in \autoref{fig:rds_android_screenshot}.

\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{gfx/rds/android_screenshot.png}
	\caption{Screenshot of the RDS demodulator on a Nexus 7}
	\label{fig:rds_android_screenshot}
\end{figure}


\subsection{PSK31\label{sec:psk31}}

\ac{PSK31} refers to phase shift keying modulation using a baud rate of 31.25
Hz.  It was developed by Peter Martinez in 1998 to introduce a narrow bandwidth
digital mode for live chatting \cite{martinez1998psk31}. Because of the simple and efficient modulation
and coding scheme (e.g. it does not have an error correction mechanism) it is
very widespread amongst amateur radio operators.

A typical setup for \ac{PSK31} operation is a \ac{SSB} transceiver connected
to the sound card of a computer. The audio channel that is fed into the computer
can contain multiple parallel \ac{PSK31} transmissions, which are demodulated
using a special software.

PSK31 is usually operated in \ac{USB} mode and shall therefore be available
in \ac{AnSiAn} when the \ac{USB} demodulator is active.
As with the \ac{RDS} demodulator the algorithm to demodulate and decode \ac{PSK31}
is first evaluated in Octave and later ported to the \ac{AnSiAn} application.

\subsubsection{PSK31 modulation scheme}

\ac{PSK31} in its basic form uses \ac{BPSK} to transmit binary information by
sending a single side band signal with either a 180 degree phase shift (digital
'1') or without a phase shift (digital '0'). Additionally, a root raised cosine
filter is used in order to smooth the phase shift and therefore keep the
bandwidth narrow.  Each symbol contains information about one bit and is always
32 ms long.

\autoref{fig:psk31_modulation} shows the modulated \ac{PSK31} signal. As already
explained in \autoref{sec:rds_modulation_scheme}, the signal may be demodulated
by using a second order loop (e.g. a Costas loop) in order to recover the phase
information and correct for small frequency variations. However, the simple approach
using envelope detection is also possible. The \ac{BPSK} code used for \ac{RDS}
demodulation can be partly reused and only needs some modifications as \ac{PSK31}
does not use Manchester Encoding.

\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{gfx/psk31/psk31_modulation.png}
	\caption{PSK31 modulation scheme: Each symbol is 32ms long. A 180° phase
	shift indicates a '0', no phase shift indicates a '1'}
	\label{fig:psk31_modulation}
\end{figure}

\subsubsection{PSK31 coding scheme}

\ac{PSK31} uses a variable length encoding called \emph{Varicode} which assigns
frequently used characters a shorter code similar to Morse. Characters are separated
by two consecutive zeros. \autoref{tab:psk31_varicode} in the appendix lists all
characters and their varicode encodings.

\subsubsection{Evaluation in Octave}

The demodulation algorithm in octave comprises the following steps:
\begin{enumerate}
	\item Downmixing the \ac{USB} signal to baseband.
	\item \ac{USB} demodulation (complex bandpass filter to
		get only the upper side band). See \autoref{fig:psk31_signal_spectrum} b.
	\item Downsampling in order to reduce the workload for the PSK31 demodulation.
	\item Envelope detection. See \autoref{fig:psk31_envelope}.
	\item Find the beginning of a '0' symbol by searching for a minimum in the
		envelope of the signal. Determine whether the next symbol is a '0' (another
		minimum is found around 32ms from the beginning of the current symbol) or
		a '1' (no minimum at the beginning of the next symbol). If another '0' was
		detected, the timing can be corrected by centering the minimum at the beginning
		of the signal and search on from there.
\end{enumerate}

\begin{figure}
\subfloat[Raw spectrum. The PSK31 signal is at around 55 KHz.]{%
  \includegraphics[clip,width=1\linewidth]{gfx/psk31/psk31_raw_signal.png}%
}

\subfloat[Spectrum after downmixing and filtering (USB demodulation)]{%
  \includegraphics[clip,width=1\linewidth]{gfx/psk31/psk31_usb_demod.png}%
}
\caption{PSK31 signal in the frequency domain (spectrum)}
\label{fig:psk31_signal_spectrum}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{gfx/psk31/psk31_envelope.png}
	\caption{Envelope of the downsampled, USB demodulated signal.}
	\label{fig:psk31_envelope}
\end{figure}

The octave code used to execute the steps mentioned above is shown in the
listing below:

\begin{lstlisting}[label=lst:octave_psk31, caption=Octave implementation of the PSK31 demodulator, language=octave]
% load signal
signal = read_cuchar_binary ("rtlsdr_434570917Hz_1000000Sps.iq");
fs = 1000000;

% downmixing (signal is at ~ 55 Khz)
fc = 55000;
t = linspace(0, length(signal)/fs, length(signal))';
carrier = e.^(2*pi*-fc*t*i);
down = carrier .* signal;

% USB demod (bandpass filter [200Hz-1000Hz])
bpfilter = firls(300, [0 200 200 1000 1000 fs/2]./(fs/2), [0 0 0 1 0 0]);
filtered = filter(bpfilter, 1, down);

% downsampling
downsampled = decimate(filtered, 16);

% BPSK demodulation
bits = psk31_bpsk_demodulate(downsampled, fs/16);

% Varicode decoding
psk31_decode(bits)
\end{lstlisting}

The \texttt{psk31\_bpsk\_demodulate()} function is shown in the following listing:

\begin{lstlisting}[label=lst:octave_psk31_bpsk, caption=Octave implementation of the BPSK demodulation, language=octave]
function demod = psk31_bpsk_demodulate(signal, fs)
  % PSK31 baud rate is 31.25 Hz
  samples_per_symbol = fs/31.25
  samples_per_symbol = ceil(samples_per_symbol)
  envelope = abs(signal);
  
  % Find the first minimum
  [minimum, idx1] = min(envelope(1:samples_per_symbol))
  
  bits = [];
  while (idx1 + samples_per_symbol*2 < length(envelope))
    % search for a minimum at the position of the next sample
    % (minimum near idx1 + samples_per_symbol)
    from = round(idx1+samples_per_symbol*0.5);
    to   = round(idx1+samples_per_symbol*1.5);
    [minimum, idx2] = min(envelope(from:to));
    idx2 = idx2 + from;
    
    % calc mean of all samples between idx1 and idx2 and calc threshold = mean/2
    m = mean(envelope(idx1:idx2));
    threshold = m/2;
    
    % Check whether we have a minimum (->0) or not (->1).
    if (envelope(idx2) > threshold)
      % In this case we have a bit 1.
      bits = [bits 1];
      idx1 = idx1 + samples_per_symbol;
    else
      % In this case we have a bit 0.
      bits = [bits 0];
      idx1 = idx2;
    endif
  endwhile
  demod = bits;
\end{lstlisting}

\subsubsection{Android Implementation}

For the Android implementation the \texttt{BPSK} class is modified to handle both
\ac{BPSK} variations needed in \ac{AnSiAn}:
\begin{itemize}
	\item RDS: BPSK with Manchester and Differential Encoding
	\item PSK31: BPSK without Manchester Encoding
\end{itemize}

Additionally, the class \texttt{PSK31} is added which is a subclass of \texttt{De\-mo\-du\-la\-tion}.
It integrates with the existing \texttt{USB} class to provide PSK31 demodulation
when USB demodulation is active.

A screenshot of the application demodulating a \ac{PSK31} signal is shown in 
\autoref{fig:psk31_android_screenshot}.

\begin{figure}
	\centering
	\includegraphics[width=1\linewidth]{gfx/psk31/psk31_android_screenshot.png}
	\caption{Screenshot of the PSK31 demodulator on a Nexus 7}
	\label{fig:psk31_android_screenshot}
\end{figure}

\subsection{Logging\label{sec:logging}}

As explained in \autoref{sec:demod_design}, digital demodulators use the EventBus library to pass demodulated text and other information to the user interface. In order to not only display but also persist this data, the class \texttt{Logger} listens to \texttt{DemodInfoEvent}s from the modulators and, if logging is enabled in the preferences by the user, writes them to logfiles.

\texttt{DemodInfoEvent} has an attribute \texttt{position}, which can be either \texttt{TOP} or \texttt{BOTTOM}, depending on whether the contained text is to be displayed on the upper or the lower line of \texttt{DemodulationInfoView}. Accordingly, the \texttt{Logger} maintains one logfile for the upper and the lower line. Every \texttt{DemodInfoEvent} is logged to one of these files depending on their \texttt{position} attribute. The paths of the logfiles can be defined in the \textsc{Demod} preferences.


\section{Support for new SDR Platforms}

\ac{AnSiAn} supports different \ac{SDR} hardware such as:
\begin{itemize}
	\item RTL-SDR dongle
	\item HackRF
\end{itemize}

The architecture of the app allows to easily add support for additional hardware,
as long as it provides IQ data samples and an Android driver is available.

\subsection{rad1o}

The \emph{rad1o} is a \ac{SDR} platform with the same design as the
\emph{HackRF} that was used as badge for the \emph{Chaos Communication Camp}
2015. Some modifications to the design were made in order to reduce costs and
therefore, minor differences exist compared to a HackRF (e.g. the option to
activate the antenna power is missing for the \emph{rad1o}).

The \emph{rad1o} offers the same USB interface as the \emph{HackRF} and can be
used with the same driver, which is \emph{hackrf\_android}. The driver only needs
two minor modifications:
\begin{enumerate}
	\item If the driver detects a \emph{rad1o}, the option to enable the antenna power
		is disabled.
	\item Because the \emph{rad1o} has a different USB product ID, the driver has
		to be extended in order to also detect a \emph{rad1o} as valid \emph{HackRF}.
\end{enumerate}

Both changes have been applied to the \emph{hackrf\_android} driver. Unfortunately, the
creators of \ac{AnSiAn} have replaced the driver library with a plain copy of the driver
source code, which makes it hard to update it to a newer version. Therefore, the
driver code was removed from \ac{AnSiAn} and replaced again with the current version
of the driver library.

This is the only change necessary to add support for the new \ac{SDR} hardware. 
The \emph{rad1o} can now be used by selecting the \emph{HackRF} source in \ac{AnSiAn}.


\subsection{SDRPlay}

The \emph{SDRplay} is a low cost \ac{SDR} with a frequency range between 100 kHz and
2 GHz. It has a 12-bit \ac{ADC} and therefore suffers less from quantification noise
than the \emph{HackRF} and the \emph{RTL-SDR} (both having an 8-bit \ac{ADC}).
Additionally, it provides passive \ac{RF} filters on the front end to prevent strong
out-of-band noise from distorting the input signal.

Martin Marinov developed an Android driver for the \emph{SDRplay} dongle, which
is currently in beta state. The API is similar to the \emph{RTL-SDR} driver which is
developed by the same person.

\subsubsection{Implementation}

The \emph{SDRplay} driver is started by an Intend with an URL of the format
\texttt{'iqsrc://\ldots'}. It takes an IP address and TCP port as arguments and
will open a socket respectively. The host app can then connect to the socket and
will receive the samples via TCP. Control commands such as changing the
frequency, sample rate or other parameters can be sent through the TCP socket
to the driver. A list of supported commands can be found on the GitHub page
of the driver. They are listed in \autoref{tab:sdrplay_cmds} in the appendix.


\subsubsection{Open Issues}

As the \emph{SDRplay} Android driver is still in beta stage, the support in AnSiAn has
also still beta status. 12-bit samples are currently not working correctly and
therefore \ac{AnSiAn} uses the RTL-SDR compatibility mode of the driver which
delivers stripped 8-bit samples. However, the 12-bit converter code is ready to
be used and might be enabled in future versions of \ac{AnSiAn}.


\section{Transmission\label{sec:transmission}}

RF Analyzer as well as \ac{AnSiAn} both have a receive-only signal processing chain, even though they support \ac{SDR} devices which are capable of transmitting signals, such as the \emph{HackRF}. This section covers the design and (partial) implementation of a transmission chain to make use of supported devices' transmission capabilities.


\subsection{Design}

The implementation of a complete transmission chain is split into multiple steps
to go along with the Agile approach (see \autoref{fig:tx_chain}).

\begin{figure}
\subfloat[Step 1: Raw IQ File Transmission]{%
  \includegraphics[clip,width=1\linewidth]{gfx/TX_chain_step1.png}%
}

\subfloat[Step 2: Modulated data is written to an IQ file and send afterwards]{%
  \includegraphics[clip,width=1\linewidth]{gfx/TX_chain_step2.png}%
}

\subfloat[Step 3: Real-time modulation, interpolation, conversion and transmission]{%
  \includegraphics[clip,width=1\linewidth]{gfx/TX_chain_final.png}%
}
\caption{Incremental implementation steps of the transmission chain}
\label{fig:tx_chain}
\end{figure}

In the first step the transmission chain will only include the \texttt{IQSink} which is
able to replay a recorded IQ file. The file has to have the correct format according
to the \ac{SDR} hardware and the sample rate cannot be adjusted.

The second step will provide \texttt{Modulators} for some digital and analog modes along
with a dummy transmission chain which will use the modulator to create an IQ
file and feed it to the \texttt{IQSink} directly.

In the final step the dummy chain is replaced by the complete transmission chain
which includes:
\begin{itemize}
	\item the \texttt{Modulators} from step two
	\item the \texttt{Interpolator} which is able to adjust the sample rate at the 
		output of the \texttt{Modulators} to a value that is supported by the \texttt{IQSink}
	\item a \texttt{float-to-binary} converter which will output the samples in the correct
		binary format according to the \ac{SDR} hardware
\end{itemize}

After the final step the transmission chain will be able to modulate and transmit
signals in real-time, assuming the Android device is capable of the necessary
calculations.

Step one and two were implemented during the third sprint and provide a proof-of-concept
implementation to demonstrate the transmission capabilities of the app.
Step three is left for future work on the application as well as the
addition of more modulators.


\subsection{Transmission of Raw I/Q Files}

RF Analyzer and \ac{AnSiAn} both use the open-source \emph{HackRF} driver from Dennis Mantz\cite{HackRF_Driver_GitHub}. This driver was released with a simple demo application that allowed the user to record signals to files and retransmit them. The logic of the \texttt{IQSink} is based on code from the demo application that was adapted to \ac{AnSiAn}'s Architecture and extended to work e.g. with the EventBus library.

For efficiency, the \emph{HackRF} driver uses asynchronous calls and cycling buffers. The calling program gets assigned free buffers from the driver's queue as they become available and fills them with the data that is to be transmitted. Unfortunately, the driver does not offer any possibility to register a callback function that is called when the driver has finished transmitting all queued data.

A drawback of the current implementation of \texttt{IQSink} is that it transmits noise for several hundred milliseconds after the driver has emptied its transmit buffer. This is because the driver apparently takes some time to realize that it sent all data and can stop transmitting. An alternative would be for the program to explicitly tell the driver to stop sending. As the program has no way of knowing when the driver finishes sending, this would either mean stopping the transmission early or having to estimate the remaining transmission time based on the sample rate and queue length. Experiments with the latter did, however, not yield satisfying results.


\subsection{Modulators}

Each \texttt{Modulator} will provide an interface to retrieve the next packet of
modulated samples. The payload data (e.g. audio or text) might be given at
instantiation time or through a queue (in order to enable real-time transmission).

As mentioned above, the step two implementation will include a dummy transmission
chain that reads the output of the \texttt{Modulator}, converts it to binary IQ
data and writes it to a temporary file which will then be transmitted by the
\texttt{IQSink} implemented in the previous section.


\subsubsection{Morse Modulator}

The Morse modulator takes a string as input payload and produces a baseband
signal with dits and dahs respectively. The Morse encoder from the previous
\ac{AnSiAn} version can be reused to transform the payload text into a
sequence of dits ('.'), dahs ('-'), breaks ('\textvisiblespace') and word
boundaries ('/'). Each character in this sequence corresponds to a predefined
packet of IQ samples (see \autoref{tab:morse_modulation}).

Because the dit and dahs each also contains silence of the length of one dit at
the beginning, the letter separator ('\textvisiblespace') and the word separator
('/') need to be one dit length shorter than they actually are.

To increase the modulation performance, the complex sinusoid is generated
ahead of time and the character translation only consists of a copy operation.

\begin{table}
	\begin{center}
		\begin{tabular}{c l}
			Morse element & Corresponding IQ sample structure \\\hline
			. & one dit length of silence + one dit length of tone \\
			- & one dit length of silence + three dit lengths of tone \\
			\textvisiblespace & two dit lengths of silence \\
			/ & six dit lengths of silence \\\hline
		\end{tabular}
		\caption{Translation from Morse elements to IQ samples}
		\label{tab:morse_modulation}
	\end{center}
\end{table}


\subsubsection{PSK31 Modulator}

The \texttt{PSK31} modulator also takes a string as input payload, encodes it with
Varicode and modulates the bits with \ac{BPSK}. The Varicode dictionary of
the PSK31 demodulator can be reused to perform the first step of creating
the bitstream from the payload text. The \ac{BPSK} modulation simply outputs
the samples based on the current state (phase) of the modulator (see
\autoref{tab:bpsk_modulation}).

\begin{table}
	\begin{center}
		\begin{tabular}{c c | c}
			Previous state (phase) & Current bit & BPSK output \\\hline
			0° & 0 & $cos(\frac{\pi \cdot 31.25 Hz \cdot t}{f_s})$ \\
			180° & 0 & $-cos(\frac{\pi \cdot 31.25 Hz \cdot t}{f_s})$ \\
			0° & 1 & 1 \\
			180° & 1 & -1 \\\hline
		\end{tabular}
		\caption{Output of the BPSK modulation based on its previous state}
		\label{tab:bpsk_modulation}
	\end{center}
\end{table}



\section{GUI\label{sec:gui}}

In order to expose the newly implemented features and their parameters to the user, changes to the user interface of \ac{AnSiAn} were necessary. \autoref{sec:prefs} describes the changes made in the preferences menu and \autoref{sec:transmit_tab} covers the \ac{GUI} of the new Transmit Tab. \autoref{sec:freq_dialog} addresses a change in the frequency selection dialog that was made to avoid unexpected behavior.


\subsection{Preferences\label{sec:prefs}}

\begin{figure}
\centering
\subfloat[The old Morse preferences\label{fig:demod_prefs_old}]{
  \includegraphics[width=0.4\textwidth]{gfx/screenshots/demod_prefs_old.png}
}
\hfill\null
\subfloat[The new demod preferences]{
  \includegraphics[width=0.4\textwidth]{gfx/screenshots/demod_prefs_new_1.png}
}
\caption{Screenshot of the preference menu on a Nexus 5X}
\label{fig:demod_prefs}
\end{figure}

\ac{AnSiAn} features a preference menu with four tabs that can be seen in \autoref{fig:demod_prefs}. In the original \ac{AnSiAn}, one of these tabs is the Morse tab that holds options for Morse demodulation and audio generation. As the new version of \ac{AnSiAn} replaces Morse audio generation with actual modulation and transmit capability and supports \ac{RDS} and \ac{PSK31} as additional digital demodulation schemes, it was decided to refactor the Morse preference tab into a general \textsc{Demod} preference tab while bundling transmission preferences for all available transmission modes in the \textsc{Transmit} Tab on the main screen (see \autoref{sec:transmit_tab}).

As can be seen in \autoref{fig:demod_prefs}, the \textsc{Demod} preference tab holds preferences for various demodulation modes. It also offers a switch to turn on \ac{PSK31} demodulation on using the \ac{USB} demodulator as well as options to turn on logging of demodulated data and to specify the respective logfiles (both not in the screenshot). 

\subsection{Transmit Tab\label{sec:transmit_tab}}

\begin{figure}
\centering
\subfloat[The old Morse Tab\label{fig:transmit_tab_old}]{
  \includegraphics[width=0.4\textwidth]{gfx/screenshots/transmit_tab_old.png}
}
\hfill\null
\subfloat[The new Transmit Tab\label{fig:transmit_tab_new}]{
  \includegraphics[width=0.4\textwidth]{gfx/screenshots/transmit_tab_new.png}
}
\caption{Screenshot of the Morse/Transmit Tab on a Nexus 5X}
\label{fig:transmit_tab}
\end{figure}

The original \ac{AnSiAn} had a \textsc{Morse} tab that offered information about the state of the Morse demodulator, the possibility to manually re-initialize the demodulator and enabled the user to generate and play Morse audio from text. It can be seen in \autoref{fig:transmit_tab}.

As the newly implemented transmission and modulation feature described in \autoref{sec:transmission} needed a graphical interface, it was decided to refactor the old \textsc{Morse} tab into a \textsc{Transmit} tab that gives the user access to the transmission features. It can be seen in \autoref{fig:transmit_tab} and provides options for the HackRF's features, such as amplification and \ac{VGA} gain. The spinner on the top lets the user select a transmit mode. Available modes are Raw IQ File, Morse and \ac{PSK31}. Fields are hidden, shown or disabled based on the selected mode, i.e. the Morse-specific options for dit duration and Morse frequency are hidden on selecting \ac{PSK31}.


\subsection{Frequency Selection Dialog\label{sec:freq_dialog}}

\begin{figure}
\centering
\subfloat[The old frequency selection dialog]{
  \includegraphics[width=0.4\textwidth]{gfx/screenshots/freq_dialog_old.png}
}
\hfill\null
\subfloat[The new frequency selection dialog]{
  \includegraphics[width=0.4\textwidth]{gfx/screenshots/freq_dialog_new.png}
}
\caption{Screenshot of the frequency selection dialog on a Nexus 5X}
\label{fig:freq_dialog}
\end{figure}

By clicking the menu on the bottom right and then ``Set Frequency'', \ac{AnSiAn} enables the user to quickly tune to a desired frequency without having to scroll through the spectrum. In the original version, this dialog also offers the user to optionally set the sampling rate (called bandwidth in the dialog) to an arbitrary value. By default, this option is enabled and the corresponding field is filled with a value that is not the current sampling rate. A user who only wants to jump to another frequency might therefore inadvertently change the sampling rate.

This has serious consequences, as the demodulation chain can currently only process sampling rates of \SI{1}{\mega{}samples\per\second}. For other sampling rates, the \texttt{Decimator} stops working and does not provide the \texttt{Demodulator} with samples any more. The user does not get any visual feedback on this and can only observe that audio and text demodulation stop working for no apparent reason. As patching the decimator to efficiently support other sampling rates would be a major task, it was decided remove the possibility to change the sample rate in order to prevent users from inadvertently breaking demodulation.

The old and the new frequency selection dialogs can be seen in \autoref{fig:freq_dialog}.
